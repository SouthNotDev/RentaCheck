// RAG Builder v3 – Gemini + Google Search Grounding (AG 2024–2025, Colombia)
// -----------------------------------------------------------------------------------------------
// Objetivo: obtener, para cada artículo especificado, el pasaje oficial y un resumen estructurado
// en un JSON estricto y compacto listo para indexar en un RAG. Se usa Gemini 2.5 Pro con la
// herramienta de Google Search, y fallback orquestado (DDG + fetch) cuando sea necesario.

import 'dotenv/config';
import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import * as cheerio from 'cheerio';
import pdfParse from 'pdf-parse/lib/pdf-parse.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const argv = yargs(hideBin(process.argv))
  .option('outdir', { type: 'string', default: path.join(__dirname, 'output') })
  .option('model', { type: 'string', default: process.env.MODEL_ID || 'gemini-2.5-pro' })
  .option('uvt', { type: 'number', default: 47065, description: 'UVT de referencia para 2024' })
  .option('concurrency', { type: 'number', default: 4 })
  .option('timeoutMs', { type: 'number', default: 120000 })
  .option('maxOutputTokens', { type: 'number', default: 3500 })
    .option('id', { type: 'string', description: 'Procesa solo el TARGET con este id' })
    .option('limit', { type: 'number', default: 999, description: 'Máximo de TARGETS a procesar' })
  .option('retries', { type: 'number', default: 1, description: 'Reintentos por target ante errores transitorios' })
  .option('noFallback', { type: 'boolean', default: false, description: 'Desactiva el fallback local (DDG+fetch) y usa solo búsqueda nativa del modelo' })
  .option('debug', { type: 'boolean', default: false, description: 'Activa logs detallados para depuración' })
  .help()
  .argv;

if (!process.env.GEMINI_API_KEY) {
  console.error('❌ Falta GEMINI_API_KEY en .env');
  process.exit(1);
}

// Logger helpers
const DEBUG = argv.debug || process.env.DEBUG_RAG === '1';
const LOG_FILE = path.join(__dirname, 'agent.log');
function ts() { return new Date().toISOString(); }
function safe(str, max = 300) {
  if (str == null) return '';
  const s = String(str);
  return s.length > max ? s.slice(0, max) + '…' : s;
}
async function logLine(level, msg) {
  const line = `[${ts()}] [${level}] ${msg}\n`;
  try { await fs.appendFile(LOG_FILE, line, 'utf8'); } catch {}
  if (level !== 'DEBUG' || DEBUG) {
    const out = level === 'ERROR' ? console.error : level === 'WARN' ? console.warn : console.log;
    out(line.trimEnd());
  }
}
function logInfo(msg) { return logLine('INFO', msg); }
function logWarn(msg) { return logLine('WARN', msg); }
function logError(msg) { return logLine('ERROR', msg); }
function logDebug(msg) { if (DEBUG) return logLine('DEBUG', msg); }

// -----------------------------\n// TARGETS: Normas/Artículos a procesar (sin URLs fijas)\n// -----------------------------\nconst TARGETS = [\n  { id: 'ET-10', norma: 'Estatuto Tributario', articulo: '10', titulo: 'Residencia fiscal' },\n  { id: 'ET-592', norma: 'Estatuto Tributario', articulo: '592', titulo: 'Contribuyentes no obligados a declarar' },\n  { id: 'ET-593', norma: 'Estatuto Tributario', articulo: '593', titulo: 'Asalariados no obligados (condiciones especiales)' },\n  { id: 'ET-594', norma: 'Estatuto Tributario', articulo: '594', titulo: 'Certificado de ingresos y retenciones como sustitutivo' },\n  { id: 'ET-594-3', norma: 'Estatuto Tributario', articulo: '594-3', titulo: 'Condiciones de control: consumos, compras, consignaciones' },\n  { id: 'ET-607', norma: 'Estatuto Tributario', articulo: '607', titulo: 'Declaración anual de activos en el exterior' },\n  { id: 'ET-407', norma: 'Estatuto Tributario', articulo: '407', titulo: 'Pagos al exterior – retención' },\n  { id: 'ET-408', norma: 'Estatuto Tributario', articulo: '408', titulo: 'Intereses al exterior – retención' },\n  { id: 'ET-409', norma: 'Estatuto Tributario', articulo: '409', titulo: 'Servicios técnicos/consultoría – retención' },\n  { id: 'ET-410', norma: 'Estatuto Tributario', articulo: '410', titulo: 'Honorarios al exterior – retención' },\n  { id: 'ET-411', norma: 'Estatuto Tributario', articulo: '411', titulo: 'Dividendos al exterior – retención' },\n  { id: 'DEC1625-1.6.1.13.2.7', norma: 'Decreto Único 1625/2016', articulo: '1.6.1.13.2.7', titulo: 'Topes de ingresos/patrimonio/consumos/consignaciones (compilación reglamentaria)' },\n  { id: 'RES-DIAN-000187-2023', norma: 'Resolución DIAN 000187/2023', articulo: '-', titulo: 'Fija UVT para 2024' },\n  { id: 'ET-6', norma: 'Estatuto Tributario', articulo: '6', titulo: 'Declaración voluntaria y efectos (saldos a favor)' },\n  { id: 'ET-329', norma: 'Estatuto Tributario', articulo: '329', titulo: 'Determinación del impuesto de PN residentes (sistema cedular / clasificación de rentas)' },\n  { id: 'ET-591', norma: 'Estatuto Tributario', articulo: '591', titulo: 'Obligación de declarar – regla general' }\n  ];

// -----------------------------\n// JSON de salida (resumen compacto, sin URLs)\n// -----------------------------\nconst SUMMARY_FIELDS = [\n  'chunk_id', 'source_id', 'norma', 'articulo', 'titulo',\n  'resumen', 'puntos_clave', 'reglas_if_then', 'topes_uvt', 'tags'\n];

// -----------------------------\n// Prompting\n// -----------------------------\nfunction buildMessages(target, uvt) {\n  const system = [\n    'Eres un asistente jurídico-tributario colombiano con búsqueda web integrada de Google. ',\n    'Por cada ARTÍCULO solicitado, debes localizar el TEXTO OFICIAL vigente y devolver un RESUMEN estructurado. ',\n    'Prioriza SIEMPRE fuentes oficiales (dian.gov.co, suin-juriscol.gov.co, minhacienda.gov.co). ',\n    'NO incluyas enlaces ni URLs. NO incluyas referencias. ',\n    'No inventes números; si no hay topes, usa null.',\n    `UVT de referencia: ${uvt}. No conviertas valores; solo menciona UVT si aparece literalmente. `,\n    'Devuelve EXCLUSIVAMENTE un objeto JSON con las claves exactas: ',\n    SUMMARY_FIELDS.join(', '),\n    '. Donde: resumen es un texto claro y suficiente, puntos_clave es un array de frases breves, reglas_if_then es un array de {if, then}, topes_uvt puede ser null.'\n  ].join('');\n  const user = [\n    `OBJETIVO: Investiga la norma: ${target.norma} – Art. ${target.articulo} – ${target.titulo}.`,\n    'Instrucciones:',\n    '  - Usa Google Search para ubicar el texto OFICIAL vigente del artículo exacto.',\n    '  - Redacta un "resumen" (5–10 frases) sin URLs.',\n    '  - "puntos_clave": 5–10 bullets de reglas/ideas centrales.',\n    '  - "reglas_if_then": condiciones accionables derivadas del pasaje (si no aplica, deja []).',\n    '  - "topes_uvt": { ingresos, patrimonio, consumos_tc, compras_consumos, consignaciones, otro } o null si no corresponde.',\n    '  - "tags": 5–10 etiquetas útiles (ej.: "obligacion_declarar", "UVT", "residente").',\n    `  - Identificadores: chunk_id por defecto ${target.id}#c1 si no lo propones; source_id=${target.id}.`,\n    '  - NO incluyas campos distintos a los listados. NO incluyas URLs.'\n  ].join('\n');\n  return { system, user };\n}

function extractGeminiText(respJson) {\n  // candidates[0].content.parts[].text\n  const candidate = respJson?.candidates?.[0];\n  if (!candidate) return '';\n  const parts = candidate.content?.parts || [];\n  for (const p of parts) {\n    if (typeof p.text === 'string' && p.text.trim()) return p.text.trim();\n  }\n  return '';\n}

async function geminiGenerate({ model, promptText, useSearch, responseSchema, maxOutputTokens }) {\n  const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent`;\n  const generationConfig = {\n    // response_mime_type is incompatible with tool use (search). Only set when useSearch=false\n    ...(useSearch ? {} : { response_mime_type: 'application/json' }),\n    // response_schema intentionally omitted\n    ...(maxOutputTokens ? { maxOutputTokens } : {})\n  };\n  const payload = {\n    contents: [\n      { role: 'user', parts: [{ text: promptText }] }\n    ],\n    ...(useSearch ? { tools: [{ google_search: {} }] } : {}),\n    ...(Object.keys(generationConfig).length ? { generationConfig } : {})\n  };\n  const res = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'x-goog-api-key': process.env.GEMINI_API_KEY,\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify(payload)\n  });\n  if (!res.ok) {\n    const text = await res.text();\n    throw new Error(`Gemini HTTP ${res.status}: ${text.slice(0, 500)}`);\n  }\n  return await res.json();\n}

function extractStructuredJsonText(resJson) {\n  const t = extractGeminiText(resJson);\n  if (t) return t;\n  const s = JSON.stringify(resJson);\n  const m = s.match(/\{.*\}$/);\n  return m ? m[0] : '';\n}

function tryParseJson(text) {\n  return JSON.parse(text);\n}

function extractJsonFromText(text) {\n  if (!text) return null;\n  // 1) Direct parse\n  try { return tryParseJson(text); } catch {}\n  // 2) Code fence with json\n  const fenceJson = text.match(/```\s*json\s*\n([\s\S]*?)```/i);\n  if (fenceJson && fenceJson[1]) {\n    const body = fenceJson[1].trim();\n    try { return tryParseJson(body); } catch {}\n  }\n  // 3) Any code fence\n  const fenceAny = text.match(/```\s*\n([\s\S]*?)```/i);\n  if (fenceAny && fenceAny[1]) {\n    const body = fenceAny[1].trim();\n    try { return tryParseJson(body); } catch {}\n  }\n  // 4) Balanced braces scan\n  const startIdx = text.indexOf('{');\n  for (let i = startIdx; i >= 0 && i < text.length; i = text.indexOf('{', i + 1)) {\n    let depth = 0;\n    for (let j = i; j < text.length; j++) {\n      const ch = text[j];\n      if (ch === '{') depth++;\n      else if (ch === '}') {\n        depth--;\n        if (depth === 0) {\n          const candidate = text.slice(i, j + 1);\n          try { return tryParseJson(candidate); } catch {}\n          break; // move to next i\n        }\n      }\n    }\n  }\n  return null;\n}

// -----------------------------\n// Fallback orquestado ligero: búsqueda (DDG/Bing) + fetch + extracción de texto\n// -----------------------------\nfunction buildOfficialQueries(target) {\n  const art = String(target.articulo).replace(/\s+/g, ' ').trim();\n  const base = [\n    `"Estatuto Tributario" "Artículo ${art}"`,\n    `"Artículo ${art}" Estatuto Tributario`,\n    `${target.norma} artículo ${art}`\n  ];\n  const sites = [\n    'site:suin-juriscol.gov.co',\n    'site:dian.gov.co',\n    'site:minhacienda.gov.co',\n    'site:funcionpublica.gov.co'\n  ];\n  const queries = [];\n  for (const b of base) for (const s of sites) queries.push(`${b} ${s}`);\n  return queries;\n}

function prioritizeResults(results) {\n  const priority = [\n    'suin-juriscol.gov.co',\n    'dian.gov.co',\n    'minhacienda.gov.co',\n    'funcionpublica.gov.co',\n    'secretariadehacienda'\n  ];\n  return results\n    .map(r => ({ r, score: priority.findIndex(d => r.url.includes(d)) }))\n    .sort((a,b) => (a.score === -1 ? 999 : a.score) - (b.score === -1 ? 999 : b.score))\n    .map(x => x.r);\n}

async function ddgSearch({ q, top_k = 6 }) {\n  const endpoints = [\n    `https://duckduckgo.com/html/?q=${encodeURIComponent(q)}&kl=co-es`,\n    `https://html.duckduckgo.com/html/?q=${encodeURIComponent(q)}&kl=co-es`,\n    `https://lite.duckduckgo.com/lite/?q=${encodeURIComponent(q)}&kl=co-es`\n  ];\n  let html = '';\n  for (const endpoint of endpoints) {\n    const resp = await fetchWithTimeout(endpoint, Math.max(15000, argv.timeoutMs));\n    if (resp.ok) { html = resp.buffer.toString('utf8'); break; }\n  }\n  if (!html) return [];\n  const $ = cheerio.load(html);\n  const results = [];\n  $('a').each((_, el) => {\n    let href = $(el).attr('href') || '';\n    if (!href) return;\n    try {\n      const urlObj = new URL(href, 'https://duckduckgo.com');\n      if (urlObj.hostname === 'duckduckgo.com' && urlObj.pathname.startsWith('/l/')) {\n        const real = urlObj.searchParams.get('uddg') || urlObj.searchParams.get('u');\n        if (real) href = decodeURIComponent(real);\n      } else if (urlObj.hostname === 'duckduckgo.com' && urlObj.searchParams.get('uddg')) {\n        href = decodeURIComponent(urlObj.searchParams.get('uddg'));\n      }\n    } catch {}\n    if (!/^https?:\/\//i.test(href)) return;\n    const title = ($(el).text() || '').trim();\n    results.push({ title, url: href, snippet: '' });\n  });\n  const seen = new Set();\n  const deduped = [];\n  for (const r of results) {\n    if (!seen.has(r.url)) { seen.add(r.url); deduped.push(r); }\n    if (deduped.length >= top_k) break;\n  }\n  return deduped;\n}

async function bingSearch({ q, top_k = 6 }) {\n  const key = process.env.BING_API_KEY;\n  if (!key) return [];\n  const url = `https://api.bing.microsoft.com/v7.0/search?q=${encodeURIComponent(q)}&mkt=es-CO&count=${Math.min(top_k, 50)}`;\n  const resp = await fetch(url, { headers: { 'Ocp-Apim-Subscription-Key': key } });\n  if (!resp.ok) return [];\n  const data = await resp.json();\n  const web = data.webPages?.value || [];\n  return web.map((w) => ({ title: w.name, url: w.url, snippet: w.snippet || '' }));\n}

async function searchOfficialCandidates(target) {\n  const baseQueries = buildOfficialQueries(target);\n  const pdfQueries = [\n    `${target.norma} artículo ${target.articulo} filetype:pdf site:dian.gov.co`,\n    `${target.norma} artículo ${target.articulo} filetype:pdf site:suin-juriscol.gov.co`,\n    `${target.norma} artículo ${target.articulo} filetype:pdf site:minhacienda.gov.co`,\n  ];\n  const queries = baseQueries.concat(pdfQueries);\n  await logDebug(`${target.id}: queries=${JSON.stringify(queries)}`);\n  const all = [];\n  const seen = new Set();\n
  if (process.env.BING_API_KEY) {\n    for (const q of queries) {\n      try {\n        const results = await bingSearch({ q, top_k: 8 });\n        await logDebug(`${target.id}: bing ${safe(q,120)} -> ${results.length} hits`);\n        for (const r of results) {\n          if (!seen.has(r.url)) { seen.add(r.url); all.push(r); }\n        }\n      } catch (err) {\n        await logWarn(`${target.id}: bing error for ${safe(q,120)}: ${safe(err?.message,120)}`);\n      }\n      if (all.length >= 12) break;\n    }\n  }\n
  if (all.length < 4) {\n    for (const q of queries) {\n      const results = await ddgSearch({ q, top_k: 8 });\n        await logDebug(`${target.id}: ddg ${safe(q,120)} -> ${results.length} hits`);\n      for (const r of results) {\n        if (!seen.has(r.url)) { seen.add(r.url); all.push(r); }\n      }\n      if (all.length >= 12) break;\n    }\n  }\n
  const prioritized = prioritizeResults(all);\n  await logInfo(`${target.id}: prioritized candidates=${prioritized.length}`);\n  return prioritized;\n}

async function fetchWithTimeout(url, timeoutMs) {\n  const ctrl = new AbortController();\n  const t = setTimeout(() => ctrl.abort(), timeoutMs);\n  try {\n    const res = await fetch(url, {\n      signal: ctrl.signal,\n      headers: {\n        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0 Safari/537.36',\n        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n        'Accept-Language': 'es-CO,es;q=0.9,en;q=0.8',\n        'Referer': 'https://duckduckgo.com/'\n      }\n    });\n    if (!res.ok) throw new Error(`HTTP ${res.status}`);\n    const buf = Buffer.from(await res.arrayBuffer());\n    const ct = (res.headers.get('content-type') || '').toLowerCase();\n    return { ok: true, buffer: buf, contentType: ct, url };\n  } catch (e) { return { ok: false, error: e, url }; } finally { clearTimeout(t); }\n}

function htmlToCleanText(html) {\n  const $ = cheerio.load(html);\n  ['script','style','noscript','header','footer','nav','aside'].forEach(sel => $(sel).remove());\n  const text = $('body').text().replace(/\s+/g, ' ').trim();\n  return text;\n}

async function extractTextFromResponse(resp) {\n  if ((resp.contentType || '').includes('pdf')) {\n    const parsed = await pdfParse(resp.buffer);\n    return parsed.text.replace(/\s+$/, '');\n  }\n  let html;\n  const m = /charset=([^;\s]+)/i.exec(resp.contentType || '');\n  if (m && m[1] && m[1].toLowerCase() !== 'utf-8' && typeof TextDecoder !== 'undefined') {\n    try {\n      const dec = new TextDecoder(m[1].toLowerCase());\n      html = dec.decode(new Uint8Array(resp.buffer));\n    } catch {\n      html = resp.buffer.toString('utf8');\n    }\n  } else {\n    html = resp.buffer.toString('utf8');\n  }\n  if ((resp.contentType || '').includes('html') || (resp.contentType || '').includes('text/')) {\n    return htmlToCleanText(html);\n  }\n  return html;\n}

// -----------------------------\n// Worker por target (primero Gemini con búsqueda nativa; si falla, fallback)\n// -----------------------------\nasync function runTargetOnce(target) {\n  const { system, user } = buildMessages(target, argv.uvt);\n  try {\n    await logInfo(`${target.id}: LLM phase (Gemini + Google Search) start`);\n    const promptText = `${system}\n\n${user}\n\nRequisitos de salida:\n- Devuelve SOLO un objeto JSON válido (sin explicación adicional).\n- Claves exactas: ${SUMMARY_FIELDS.join(', ')}.`;\n    const resJson = await Promise.race([\n      geminiGenerate({ model: argv.model, promptText, useSearch: true, responseSchema: undefined, maxOutputTokens: argv.maxOutputTokens }),\n      new Promise((_, reject) => setTimeout(() => reject(new Error('LLM timeout')), argv.timeoutMs))\n    ]);\n    await logInfo(`${target.id}: LLM phase finished`);\n
    const jsonText = extractStructuredJsonText(resJson);\n    await logDebug(`${target.id}: LLM raw jsonText length=${jsonText ? jsonText.length : 0}`);\n    if (!jsonText) throw new Error('Salida vacía');\n
    let parsed = extractJsonFromText(jsonText);\n    if (!parsed) throw new Error('JSON inválido');\n    await logInfo(`${target.id}: JSON parse OK`);\n    return finalizeParsed(target, parsed);\n  } catch (e) {\n    await logWarn(`${target.id}: LLM phase failed: ${safe(e?.message, 200)}`);\n    if (argv.noFallback) throw e;\n    await logInfo(`${target.id}: Fallback phase (orchestrated) start`);\n    const parsed = await fallbackOrchestrated(target);\n    await logInfo(`${target.id}: Fallback phase finished`);\n    return finalizeParsed(target, parsed);\n  }\n}

async function fallbackOrchestrated(target) {\n  const candidates = await searchOfficialCandidates(target);\n  await logInfo(`${target.id}: candidates found=${candidates.length}`);\n  if (!candidates.length) throw new Error('No se encontraron resultados');\n  let picked = null;\n  let text = '';\n  for (const c of candidates) {\n    await logDebug(`${target.id}: try fetch ${safe(c.url, 180)}`);\n    const fetched = await fetchWithTimeout(c.url, argv.timeoutMs);\n    if (!fetched.ok) { await logWarn(`${target.id}: fetch failed for ${safe(c.url, 180)}: ${safe(fetched.error, 120)}`); continue; }\n    await logDebug(`${target.id}: fetched contentType=${safe(fetched.contentType, 80)} bytes=${fetched.buffer?.length || 0}`);\n    try {\n      text = await extractTextFromResponse(fetched);\n      picked = c;\n      await logInfo(`${target.id}: picked source (no se guardará URL) textLen=${text.length}`);\n      break;\n    } catch (err) {\n      await logWarn(`${target.id}: extract failed for ${safe(c.url, 180)}: ${safe(err?.message, 120)}`);\n    }\n  }\n  if (!picked) throw new Error('No se pudieron descargar candidatos oficiales');\n
  const promptText = [\n    'Eres un asistente jurídico-tributario. Estructura la información SOLO usando el texto proporcionado en un JSON válido.',\n    'No incluyas URLs ni referencias. Campos exactos: ',\n    SUMMARY_FIELDS.join(', '),\n    'Texto oficial (recortado si es muy largo):',\n    text.slice(0, 120000)\n  ].join('\n\n');\n  await logInfo(`${target.id}: LLM structuring from fetched text start`);\n  const resJson = await geminiGenerate({ model: argv.model, promptText, useSearch: false, responseSchema: undefined, maxOutputTokens: argv.maxOutputTokens });\n  await logInfo(`${target.id}: LLM structuring finished`);\n  const jsonText = extractStructuredJsonText(resJson);\n  await logDebug(`${target.id}: Fallback jsonText length=${jsonText ? jsonText.length : 0}`);\n  if (!jsonText) throw new Error('Salida vacía');\n  const parsed = extractJsonFromText(jsonText);\n  if (!parsed) throw new Error('JSON inválido');\n  return parsed;\n}

function finalizeParsed(target, parsed) {\n  parsed.chunk_id = parsed.chunk_id || `${target.id}#c1`;\n  parsed.source_id = target.id;\n  parsed.norma = target.norma;\n  parsed.articulo = target.articulo;\n  parsed.titulo = target.titulo;\n  parsed.resumen = parsed.resumen || parsed.resumen_llano || '';\n  if (!Array.isArray(parsed.puntos_clave)) parsed.puntos_clave = [];\n  if (!Array.isArray(parsed.reglas_if_then)) parsed.reglas_if_then = [];\n  if (!parsed.topes_uvt) parsed.topes_uvt = { ingresos: null, patrimonio: null, consumos_tc: null, compras_consumos: null, consignaciones: null, otro: null };\n  if (!Array.isArray(parsed.tags)) parsed.tags = [];\n  // Eliminar cualquier URL sobrante que el modelo haya puesto accidentalmente\n  for (const k of Object.keys(parsed)) {\n    if (typeof parsed[k] === 'string' && /https?:\/\//i.test(parsed[k])) parsed[k] = parsed[k].replace(/https?:\/\/\S+/gi, '').trim();\n  }\n  return parsed;\n}

// -----------------------------\n// Concurrencia simple (cola)\n// -----------------------------\nasync function mapWithConcurrency(items, concurrency, iterator) {\n  const results = new Array(items.length);\n  let nextIndex = 0;\n  let active = 0;\n  return await new Promise((resolve) => {\n    const launchNext = () => {\n      if (nextIndex >= items.length && active === 0) return resolve(results);\n      while (active < concurrency && nextIndex < items.length) {\n        const current = nextIndex++;\n        active++;\n        Promise.resolve()\n          .then(() => iterator(items[current], current))\n          .then((r) => { results[current] = { ok: true, value: r }; })\n          .catch((err) => { results[current] = { ok: false, error: String(err && err.message ? err.message : err) }; })\n          .finally(() => { active--; launchNext(); });\n      }\n    };\n    launchNext();\n  });\n}

// -----------------------------\n// Main\n// -----------------------------\nasync function main() {\n  const outDir = path.resolve(argv.outdir);\n  await fs.mkdir(outDir, { recursive: true });\n  try { await fs.writeFile(LOG_FILE, '', 'utf8'); } catch {}

  const corpusPath = path.join(outDir, 'corpus_normas_v3.jsonl');\n  const indexPath = path.join(outDir, 'index_normas_v3.json');\n  await fs.writeFile(corpusPath, '', 'utf8');

  let runTargets = TARGETS.slice();\n  if (argv.id) runTargets = runTargets.filter(t => t.id === argv.id);\n  if (argv.limit && runTargets.length > argv.limit) runTargets = runTargets.slice(0, argv.limit);

  await logInfo(`run start: items=${runTargets.length} concurrency=${argv.concurrency} timeoutMs=${argv.timeoutMs}`);

  const results = await mapWithConcurrency(\n    runTargets,\n    Math.max(1, Number(argv.concurrency) || 1),\n    async (target) => {\n      let attempt = 0;\n      while (true) {\n        try {\n          const json = await runTargetOnce(target);\n          await fs.appendFile(corpusPath, JSON.stringify(json) + '\n', 'utf8');\n          await logInfo(`${target.id}: written chunk=${json.chunk_id}`);\n          return { targetId: target.id, chunkId: json.chunk_id };\n        } catch (e) {\n          const msg = String(e && e.message ? e.message : e);\n          const transient = /timeout|rate limit|temporarily|overloaded|ECONN|ETIMEDOUT|ENET|TLS|fetch|429/i.test(msg);\n          if (transient && attempt < argv.retries) {\n            attempt++;\n            await logWarn(`${target.id}: transient error, retry ${attempt}/${argv.retries}: ${safe(msg, 200)}`);\n            continue;\n          }\n          await logError(`${target.id}: failed: ${safe(msg, 300)}`);\n          return { targetId: target.id, error: msg };\n        }\n      }\n    }\n  );

  const index = {};\n  for (let i = 0; i < runTargets.length; i++) {\n    const t = runTargets[i];\n    const r = results[i];\n    if (r && r.ok && r.value) {\n      index[t.id] = {\n        source_id: t.id,\n        norma: t.norma,\n        articulo: t.articulo,\n        titulo: t.titulo,\n        chunks: [{ chunk_id: r.value.chunkId }]\n      };\n    } else {\n      index[t.id] = {\n        source_id: t.id,\n        norma: t.norma,\n        articulo: t.articulo,\n        titulo: t.titulo,\n        chunks: [],\n        error: r && r.error ? r.error : 'unknown'\n      };\n    }\n  }

  await fs.writeFile(indexPath, JSON.stringify(index, null, 2), 'utf8');\n  await logInfo(`run finished -> corpus=${corpusPath} index=${indexPath}`);\n}

main().catch(err => { console.error('ERROR FATAL:', err); process.exit(1); });